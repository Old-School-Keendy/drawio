# 线程池

## 1、execute(Runnable command)方法

```java
  /**
     * Executes the given task sometime in the future.  The task
     * may execute in a new thread or in an existing pooled thread.
     *
     * If the task cannot be submitted for execution, either because this
     * executor has been shutdown or because its capacity has been reached,
     * the task is handled by the current {@code RejectedExecutionHandler}.
     *
     * @param command the task to execute
     * @throws RejectedExecutionException at discretion of
     *         {@code RejectedExecutionHandler}, if the task
     *         cannot be accepted for execution
     * @throws NullPointerException if {@code command} is null
     */
    //command 可以是普通的Runnable 实现类，也可以是 FutureTask
    public void execute(Runnable command) {
        //非空判断..
        if (command == null)
            throw new NullPointerException();
        /*
         * Proceed in 3 steps:
         *
         * 1. If fewer than corePoolSize threads are running, try to
         * start a new thread with the given command as its first
         * task.  The call to addWorker atomically checks runState and
         * workerCount, and so prevents false alarms that would add
         * threads when it shouldn't, by returning false.
         *
         * 2. If a task can be successfully queued, then we still need
         * to double-check whether we should have added a thread
         * (because existing ones died since last checking) or that
         * the pool shut down since entry into this method. So we
         * recheck state and if necessary roll back the enqueuing if
         * stopped, or start a new thread if there are none.
         *
         * 3. If we cannot queue task, then we try to add a new
         * thread.  If it fails, we know we are shut down or saturated
         * and so reject the task.
         */
        //获取ctl最新值赋值给c，ctl ：高3位 表示线程池状态，低位表示当前线程池线程数量。
        int c = ctl.get();
        //workerCountOf(c) 获取出当前线程数量
        //条件成立：表示当前线程数量小于核心线程数，此次提交任务，直接创建一个新的worker，对应线程池中多了一个新的线程。
        if (workerCountOf(c) < corePoolSize) {
            //addWorker 即为创建线程的过程，会创建worker对象，并且将command作为firstTask
            //core == true 表示采用核心线程数量限制  false表示采用 maximumPoolSize
            if (addWorker(command, true))
                //创建成功后，直接返回。addWorker方法里面会启动新创建的worker，将firstTask执行。
                return;

            //执行到这条语句，说明addWorker一定是失败了...
            //有几种可能呢？？
            //1.存在并发现象，execute方法是可能有多个线程同时调用的，当workerCountOf(c) < corePoolSize成立后，
            //其它线程可能也成立了，并且向线程池中创建了worker。这个时候线程池中的核心线程数已经达到，所以...
            //2.当前线程池状态发生改变了。 RUNNING SHUTDOWN STOP TIDYING　TERMINATION
            //当线程池状态是非RUNNING状态时，addWorker(firstTask!=null, true|false) 一定会失败。
            //SHUTDOWN 状态下，也有可能创建成功。前提 firstTask == null 而且当前 queue  不为空。特殊情况。
            c = ctl.get();
        }


        //执行到这里有几种情况？
        //1.当前线程数量已经达到corePoolSize
        //2.addWorker失败..

        //条件成立：说明当前线程池处于running状态，则尝试将 task 放入到workQueue中。
        if (isRunning(c) && workQueue.offer(command)) {
            //执行到这里，说明offer提交任务成功了..

            //再次获取ctl保存到recheck。
            int recheck = ctl.get();

            //条件一：! isRunning(recheck) 成立：说明你提交到队列之后，线程池状态被外部线程给修改 比如：shutdown() shutdownNow()
            //这种情况 需要把刚刚提交的任务删除掉。
            //条件二：remove(command) 有可能成功，也有可能失败
            //成功：提交之后，线程池中的线程还未消费（处理）
            //失败：提交之后，在shutdown() shutdownNow()之前，就被线程池中的线程 给处理。
            if (! isRunning(recheck) && remove(command))
                //提交之后线程池状态为 非running 且 任务出队成功，走个拒绝策略。
                reject(command);

            //有几种情况会到这里？
            //1.当前线程池是running状态(这个概率最大)
            //2.线程池状态是非running状态 但是remove提交的任务失败.

            //担心 当前线程池是running状态，但是线程池中的存活线程数量是0，这个时候，如果是0的话，会很尴尬，任务没线程去跑了,
            //这里其实是一个担保机制，保证线程池在running状态下，最起码得有一个线程在工作。
            else if (workerCountOf(recheck) == 0)
                addWorker(null, false);
        }

        //执行到这里，有几种情况？
        //1.offer失败
        //2.当前线程池是非running状态

        //1.offer失败，需要做什么？ 说明当前queue 满了！这个时候 如果当前线程数量尚未达到maximumPoolSize的话，会创建新的worker直接执行command
        //假设当前线程数量达到maximumPoolSize的话，这里也会失败，也走拒绝策略。

        //2.线程池状态为非running状态，这个时候因为 command != null addWorker 一定是返回false。
        else if (!addWorker(command, false))
            reject(command);

    }
```

## 2、addWorker(Runnable command)方法

```java
  /*
     * Methods for creating, running and cleaning up after workers
     */

    /**
     * Checks if a new worker can be added with respect to current
     * pool state and the given bound (either core or maximum). If so,
     * the worker count is adjusted accordingly, and, if possible, a
     * new worker is created and started, running firstTask as its
     * first task. This method returns false if the pool is stopped or
     * eligible to shut down. It also returns false if the thread
     * factory fails to create a thread when asked.  If the thread
     * creation fails, either due to the thread factory returning
     * null, or due to an exception (typically OutOfMemoryError in
     * Thread.start()), we roll back cleanly.
     *
     * @param firstTask the task the new thread should run first (or
     * null if none). Workers are created with an initial first task
     * (in method execute()) to bypass queuing when there are fewer
     * than corePoolSize threads (in which case we always start one),
     * or when the queue is full (in which case we must bypass queue).
     * Initially idle threads are usually created via
     * prestartCoreThread or to replace other dying workers.
     *
     * @param core if true use corePoolSize as bound, else
     * maximumPoolSize. (A boolean indicator is used here rather than a
     * value to ensure reads of fresh values after checking other pool
     * state).
     * @return true if successful
     */
    // 返回结果:
    // true: 增加线程成功
    // false: 1.
    private boolean addWorker(Runnable firstTask, boolean core) {
        retry:
        // 自旋, 外部: 主要校验rs状态
        for (int c = ctl.get();;) {
            // Check if queue empty only if necessary.
            // 条件一: rs >= shutdown (只要不是running状态, 就返回false)
            // 条件二: 线程池状态不是shutdown || 任务不是null || 任务队列是空的 (前置条件,当前线程不是running状态)
            if (runStateAtLeast(c, SHUTDOWN)
                && (runStateAtLeast(c, STOP)
                    || firstTask != null
                    || workQueue.isEmpty()))
                return false;

            // 以上代码就是判断当前线程池状态是否可以添加线程

            // 自旋,内部: 主要校验wc数量
            // 走到这里只有两种情况:
            // CASE-1: 线程池是runnning状态
            // CASE-2: 线程池是shutdown状态,此时队列里面还有任务没有处理完(即队列不空),这个时候允许添加worker,但是不能提交task(即task是null)
            for (;;) {
                // 如果此时线程数超过了最大/核心线程数,不允许增加线程
                if (workerCountOf(c)
                    >= ((core ? corePoolSize : maximumPoolSize) & COUNT_MASK)) {return false;}

                // 条件成功: 线程数没有超过最大线程数, 说明记录线程数量已经加一成功
                if (compareAndIncrementWorkerCount(c))
                    break retry;

                // 条件失败: 说明此时可能有其他线程已经修改过ctl的值了:
                // 可能发生什么事?
                // CASE-1: 其他线程execute(),执行过加一操作了,导致cas失败
                // CASE-2: 外部可能调用了shutdown()或者shutdownNow()方法, ctl高3位不表示状态, 线程池状态发生了改变也会影响cas
                // 重新获取ctl的值
                c = ctl.get();  // Re-read ctl
                if (runStateAtLeast(c, SHUTDOWN))
                    // 线程池状态改变引起cas失败, 重新开始外部循环
                    continue retry;

                // 否则的话,就是因为wc数量变化导致的cas失败,重新进行内部循环
                // else CAS failed due to workerCount change; retry inner loop
            }
        }


        // 执行到这里,说明rs状态和wc数量都没有问题,可以执行增加线程的操作了(但还是有可能会失败)

        //表示创建的worker是否已经启动，false未启动  true启动
        boolean workerStarted = false;
        //表示创建的worker是否添加到池子中了 默认false 未添加 true是添加。
        boolean workerAdded = false;
        Worker w = null;
        try {
            //创建Worker，就是在这里使用到了ThreadFactory, 执行完后，线程应该是已经创建好了。
            w = new Worker(firstTask);
            //将新创建的worker节点的线程 赋值给 t
            final Thread t = w.thread;

            //为了防止ThreadFactory 实现类有bug，因为ThreadFactory 是一个接口，谁都可以实现。
            // 如果传入的线程是null, 就会报错
            //Doug lea考虑的比较全面。肯定会防止他自己的程序报空指针，所以这里一定要做！
            if (t != null) {
                // 将全局锁的引用保存到mainLock
                final ReentrantLock mainLock = this.mainLock;
                //持有全局锁，可能会阻塞，直到获取成功为止，同一时刻 操纵 线程池内部相关的操作，都必须持锁。
                mainLock.lock();

                // 这里加锁之后,其他线程是无法修改当前线程池状态的
                try {
                    // Recheck while holding lock.
                    // Back out on ThreadFactory failure or if
                    // shut down before lock acquired.
                    // 获取最新的ctl值
                    int c = ctl.get();


                    // 条件一: 线程池是running状态, 最正常的状态
                    // 条件二: 线程池是shutdown状态, 而且任务是null, 也允许增加worker
                    if (isRunning(c) ||
                        (runStateLessThan(c, STOP) && firstTask == null)) {

                        //防止脑子发热的程序员，ThreadFactory创建线程返回给外部之前，将线程start了
                        if (t.getState() != Thread.State.NEW)
                            throw new IllegalThreadStateException();

                        // 将worker添加到线程池中
                        workers.add(w);
                        //表示线程已经追加进线程池中了。
                        workerAdded = true;
                        // 获取最新的线程池线程数量
                        int s = workers.size();
                        //条件成立：说明当前线程数量是一个新高。更新largestPoolSize
                        if (s > largestPoolSize)
                            largestPoolSize = s;
                    }
                } finally {
                    // 释放线程池全局锁。
                    mainLock.unlock();
                }
                //条件成立:说明 添加worker成功
                //条件失败：说明线程池在lock之前，线程池状态发生了变化，导致添加失败。
                if (workerAdded) {
                    //成功后，则将创建的worker启动，线程启动。
                    container.start(t);
                    //启动标记设置为true
                    workerStarted = true;
                }
            }
        } finally {
            if (! workerStarted)
                // 启动失败
                // 1. 回滚wc数量
                // 2. 将当前worker从workers里面清除出去
                addWorkerFailed(w);
        }
        return workerStarted;
    }

    /**
     * Rolls back the worker thread creation.
     * - removes worker from workers, if present
     * - decrements worker count
     * - rechecks for termination, in case the existence of this
     *   worker was holding up termination
     */
    private void addWorkerFailed(Worker w) {
        final ReentrantLock mainLock = this.mainLock;
        // 持有全局锁
        mainLock.lock();
        try {
            if (w != null)
                // workers 里面移除 worker
                workers.remove(w);
            // 回滚wc数量
            decrementWorkerCount();
            // ...
            tryTerminate();
        } finally {
            // 释放全局锁
            mainLock.unlock();
        }
    }
```

## 3、 runWorker方法

```java
    /**
     * Main worker run loop.  Repeatedly gets tasks from queue and
     * executes them, while coping with a number of issues:
     *
     * 1. We may start out with an initial task, in which case we
     * don't need to get the first one. Otherwise, as long as pool is
     * running, we get tasks from getTask. If it returns null then the
     * worker exits due to changed pool state or configuration
     * parameters.  Other exits result from exception throws in
     * external code, in which case completedAbruptly holds, which
     * usually leads processWorkerExit to replace this thread.
     *
     * 2. Before running any task, the lock is acquired to prevent
     * other pool interrupts while the task is executing, and then we
     * ensure that unless pool is stopping, this thread does not have
     * its interrupt set.
     *
     * 3. Each task run is preceded by a call to beforeExecute, which
     * might throw an exception, in which case we cause thread to die
     * (breaking loop with completedAbruptly true) without processing
     * the task.
     *
     * 4. Assuming beforeExecute completes normally, we run the task,
     * gathering any of its thrown exceptions to send to afterExecute.
     * We separately handle RuntimeException, Error (both of which the
     * specs guarantee that we trap) and arbitrary Throwables.
     * Because we cannot rethrow Throwables within Runnable.run, we
     * wrap them within Errors on the way out (to the thread's
     * UncaughtExceptionHandler).  Any thrown exception also
     * conservatively causes thread to die.
     *
     * 5. After task.run completes, we call afterExecute, which may
     * also throw an exception, which will also cause thread to
     * die. According to JLS Sec 14.20, this exception is the one that
     * will be in effect even if task.run throws.
     *
     * The net effect of the exception mechanics is that afterExecute
     * and the thread's UncaughtExceptionHandler have as accurate
     * information as we can provide about any problems encountered by
     * user code.
     *
     * @param w the worker
     */
    final void runWorker(Worker w) {
        // wt == w.thread
        Thread wt = Thread.currentThread();
        // 将初始化执行task赋值给firstTask
        Runnable task = w.firstTask;
        // 清空w.firstTask引用
        w.firstTask = null;
        // 这里为什么先调用unlock?
        // 为了初始化worker state == 0 和 exclusiveOwnerThread == null
        w.unlock(); // allow interrupts

        // 是否异常退出的标志,  false-正常退出; true-异常退出,需要做一些处理
        boolean completedAbruptly = true;
        try {
            // 条件一: 如果当前任务是空就直接去任务队列中获取
            // 条件二: 获取来的任务也是空说明当前线程需要执行结束逻辑
            while (task != null || (task = getTask()) != null) {
                // worker设置独占锁
                //Q: 为什么要设置独占锁呢？
                //A: shutdown时会判断当前worker状态，根据独占锁是否空闲来判断当前worker是否正在工作。
                w.lock();
                // If pool is stopping, ensure thread is interrupted;
                // 如果池正在停止，请确保线程被中断
                // if not, ensure thread is not interrupted.
                //如果没有，请确保线程没有中断
                // This requires a recheck in second case to deal with
                // shutdownNow race while clearing interrupt.
                // 这需要在第二种情况下进行重新检查，来处理正在清理中断时调用shutdownNow方法的情况。


                // 条件一: runStateAtLeast(ctl.get(), STOP) 成立说明当前线程池是出于stop/tidying/terminated状态
                // 短路或触发,直接结合 !wt.isInterrupted() 判断
                // 表示 当前线程池状态>=stop 且 当前线程还未中断 ==> 需要执行中断操作

                // 条件二: 条件一false的前提下, 也就是线程池状态 < stop
                // Thread.interrupted() && runStateAtLeast(ctl.get(), STOP)) ,线程是否中断 && 线程池状态是否 >= stop
                if ((runStateAtLeast(ctl.get(), STOP)
                    || (Thread.interrupted() && runStateAtLeast(ctl.get(), STOP)))
                    && !wt.isInterrupted())
                    wt.interrupt();
                try {
                    // 钩子方法, 留给子类实现的
                    beforeExecute(wt, task);
                    try {
                        //task 可能是FutureTask 也可能是 普通的Runnable接口实现类。
                        //如果前面是通过submit()提交的 runnable/callable 会被封装成 FutureTask
                        task.run();
                        afterExecute(task, null);
                    } catch (Throwable ex) {
                        // 钩子方法, 留给子类实现的
                        afterExecute(task, ex);
                        throw ex;
                    }
                } finally {
                    // 将局部变量设置为null
                    task = null;
                    // 更新worker完成任务数量
                    w.completedTasks++;
                    // 释放独占锁
                    // 1. 正常情况下, 会再次回到getTask()去获取任务
                    // 2. task.run()的时候抛出异常了
                    w.unlock();
                }
            }

            //Q: 什么情况下，会来到这里？
            //A: getTask()方法返回null时，说明当前线程应该执行退出逻辑了。
            completedAbruptly = false;
        } finally {
            //task.run()内部抛出异常时，直接从 w.unlock() 那里 跳到这一行。
            //正常退出 completedAbruptly == false
            //异常退出 completedAbruptly == true
            processWorkerExit(w, completedAbruptly);
        }
    }
    
    
    
    
    
    
    
    /**
     * Performs cleanup and bookkeeping for a dying worker. Called
     * only from worker threads. Unless completedAbruptly is set,
     * assumes that workerCount has already been adjusted to account
     * for exit.  This method removes thread from worker set, and
     * possibly terminates the pool or replaces the worker if either
     * it exited due to user task exception or if fewer than
     * corePoolSize workers are running or queue is non-empty but
     * there are no workers.
     *
     *
     * @param w the worker
     * @param completedAbruptly if the worker died due to user exception
     */
    private void processWorkerExit(Worker w, boolean completedAbruptly) {
        //条件成立：代表当前w 这个worker是发生异常退出的，task任务执行过程中向上抛出异常了..
        if (completedAbruptly) // If abrupt, then workerCount wasn't adjusted
            // ctl减一
            decrementWorkerCount();

        // 获取线程池的全局锁引用
        final ReentrantLock mainLock = this.mainLock;
        // 加锁
        mainLock.lock();
        try {
            // 当前worker处理task数量汇总到线程池处理的task数量
            completedTaskCount += w.completedTasks;
            // 将worker从线程池中移除
            workers.remove(w);
        } finally {
            // 释放全局锁
            mainLock.unlock();
        }

        tryTerminate();

        // 获取最新的ctl的值
        int c = ctl.get();
        //条件成立：当前线程池状态为 RUNNING 或者 SHUTDOWN状态
        if (runStateLessThan(c, STOP)) {
            //条件成立：当前线程是正常退出
            if (!completedAbruptly) {
                //min表示线程池最低持有的线程数量
                //allowCoreThreadTimeOut == true => 说明核心线程数内的线程，也会超时被回收。 min == 0
                //allowCoreThreadTimeOut == false => min == corePoolSize
                int min = allowCoreThreadTimeOut ? 0 : corePoolSize;

                //线程池状态：RUNNING SHUTDOWN
                //条件一：假设min == 0 成立
                //条件二：! workQueue.isEmpty() 说明任务队列中还有任务，最起码要留一个线程。
                if (min == 0 && ! workQueue.isEmpty())
                    min = 1;
                //条件成立：线程池中还拥有足够的线程。
                //考虑一个问题： workerCountOf(c) >= min  =>  (0 >= 0) ?
                //有可能！
                //什么情况下？ 当线程池中的核心线程数是可以被回收的情况下，会出现这种情况，这种情况下，当前线程池中的线程数 会变为0
                //下次再提交任务时，会再创建线程。
                if (workerCountOf(c) >= min)
                    return; // replacement not needed
            }
            
            //1.当前线程在执行task时 发生异常，这里一定要创建一个新worker顶上去。
            //2.!workQueue.isEmpty() 说明任务队列中还有任务，最起码要留一个线程。 当前状态为 RUNNING || SHUTDOWN
            //3.当前线程数量 < corePoolSize值，此时会创建线程，维护线程池数量在corePoolSize个。
            addWorker(null, false);
        }
    }

```

### 4、getTask方法

```java
  /**
     * Performs blocking or timed wait for a task, depending on
     * current configuration settings, or returns null if this worker
     * must exit because of any of:
     * 1. There are more than maximumPoolSize workers (due to
     *    a call to setMaximumPoolSize).
     *    当前线程超过了最大线程数(由于setMaximumPoolSize方法的调用改变了最大线程数)
     *
     * 2. The pool is stopped.
     *    线程池是stop状态
     *
     * 3. The pool is shutdown and the queue is empty.
     *    线程池shutdown状态, 且任务队列为空
     *
     * 4. This worker timed out waiting for a task, and timed-out
     *    workers are subject to termination (that is,
     *    {@code allowCoreThreadTimeOut || workerCount > corePoolSize})
     *    both before and after the timed wait, and if the queue is
     *    non-empty, this worker is not the last thread in the pool.
     *    此工作线程在等待任务时超时，且超时的工作线程在超时等待之前和之后都是可终止的, (即｛@code allowCoreThreadTimeOut||workerCount>corePoolSize｝），
     *    如果队列不是空的，则此工作线程不是池中的最后一个线程。
     *
     *
     * @return task, or null if the worker must exit, in which case
     *         workerCount is decremented
     */
    //什么情况下会返回null？
    //1.rs >= STOP 成立说明：当前的状态最低也是STOP状态，一定要返回null了
    //2.前置条件 状态是 SHUTDOWN ，workQueue.isEmpty()
    //3.线程池中的线程数量 超过 最大限制时，会有一部分线程返回Null
    //4.线程池中的线程数超过corePoolSize时，会有一部分线程 超时后，返回null。
    private Runnable getTask() {
        //表示当前线程获取任务是否超时 默认false, true-已超时
        boolean timedOut = false; // Did the last poll() time out?

        for (;;) {
            //获取最新ctl值保存到临时变量c中。
            int c = ctl.get();

            // Check if queue empty only if necessary.
            // 条件1: rs>=shutdown, 说明线程池是非运行状态
            // 条件2: (runStateAtLeast(c, STOP) || workQueue.isEmpty())
            // 条件2.1: rs >= stop 当前状态最低也是stop, 一定会放回null
            // 条件2.2:  shutdown <= rs < stop, 线程池状态就是shutdown ,任务队列为空, 就返回null
            if (runStateAtLeast(c, SHUTDOWN)
                && (runStateAtLeast(c, STOP) || workQueue.isEmpty())) {
                // ctl减少worker count
                decrementWorkerCount();
                return null;
            }

            // 此时有两种情况
            // 1. rs是running状态
            // 2. rs是shutdown状态, 但是任务队列中还未空, 此时可以继续创建线程

            // 获得线程池中线程的数量
            int wc = workerCountOf(c);

            // Are workers subject to culling?
            // timed == true, 表示当前这个线程在获取task时是支持超市机智的, 使用 queue.poll(xxx,xxx); 当task超时之后直接返回null;
            // timed == false, 表示当前这个线程 获取 task 时 是不支持超时机制的，当前线程会使用 queue.take();

            // allowCoreThreadTimeOut默认为false, 设置为true后, 表示核心线程也可以被回收
            //情况1：allowCoreThreadTimeOut == true 表示核心线程数量内的线程 也可以被回收。
            //所有线程 都是使用queue.poll(xxx,xxx) 超时机制这种方式获取task.
            //情况2：allowCoreThreadTimeOut == false 表示当前线程池会维护核心数量内的线程。
            //wc > corePoolSize
            //条件成立：当前线程池中的线程数量是大于核心线程数的，此时让所有路过这里的线程，都是用poll 支持超时的方式去获取任务，
            //这样，就会可能有一部分线程获取不到任务，获取不到任务 返回Null，然后..runWorker会执行线程退出逻辑。
            boolean timed = allowCoreThreadTimeOut || wc > corePoolSize;
            

            //条件一：(wc > maximumPoolSize || (timed && timedOut))
            //1.1：wc > maximumPoolSize  为什么会成立？setMaximumPoolSize()方法，可能外部线程将线程池最大线程数设置为比初始化时的要小
            //1.2: (timed && timedOut) 条件成立：前置条件，当前线程使用 poll方式获取task。上一次循环时  使用poll方式获取任务时，超时了
            //条件一 为true 表示 线程可以被回收，达到回收标准，当确实需要回收时再回收。

            //条件二：(wc > 1 || workQueue.isEmpty())
            //2.1: wc > 1  条件成立，说明当前线程池中还有其他线程，当前线程可以直接回收，返回null
            //2.2: workQueue.isEmpty() 前置条件 wc == 1， 条件成立：说明当前任务队列 已经空了，最后一个线程，也可以放心的退出。
            if ((wc > maximumPoolSize || (timed && timedOut))
                && (wc > 1 || workQueue.isEmpty())) {
                //使用CAS机制 将 ctl值 -1 ,减1成功的线程，返回null
                //CAS成功的，返回Null
                //CAS失败？ 为什么会CAS失败？
                //1.其它线程先你一步退出了
                //2.线程池状态发生变化了。
                if (compareAndDecrementWorkerCount(c))
                    return null;
                //再次自旋时，timed有可能就是false了，因为当前线程cas失败，很有可能是因为其它线程成功退出导致的，再次咨询时
                //检查发现，当前线程 就可能属于 不需要回收范围内了。
                continue;
            }


            try {
                //获取任务的逻辑
                Runnable r = timed ?
                    workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :
                    workQueue.take();
                if (r != null)
                    return r;
                
                // 当前任务超时了
                timedOut = true;
            } catch (InterruptedException retry) {
                timedOut = false;
            }
        }
    }
```

## 5、 shutdown 和 shutdownNow 方法

```java
    /**
     * Initiates an orderly shutdown in which previously submitted
     * tasks are executed, but no new tasks will be accepted.
     * Invocation has no additional effect if already shut down.
     *
     * <p>This method does not wait for previously submitted tasks to
     * complete execution.  Use {@link #awaitTermination awaitTermination}
     * to do that.
     *
     * @throws SecurityException {@inheritDoc}
     */
    public void shutdown() {
        final ReentrantLock mainLock = this.mainLock;
        mainLock.lock();
        try {
            checkShutdownAccess();
            // 设置线程池状态为shutdowm
            advanceRunState(SHUTDOWN);
            // 中断线程池中所有线程
            interruptIdleWorkers();
            onShutdown(); // hook for ScheduledThreadPoolExecutor
        } finally {
            mainLock.unlock();
        }
        tryTerminate();
    }
    
      /**
     * Attempts to stop all actively executing tasks, halts the
     * processing of waiting tasks, and returns a list of the tasks
     * that were awaiting execution. These tasks are drained (removed)
     * from the task queue upon return from this method.
     *
     * <p>This method does not wait for actively executing tasks to
     * terminate.  Use {@link #awaitTermination awaitTermination} to
     * do that.
     *
     * <p>There are no guarantees beyond best-effort attempts to stop
     * processing actively executing tasks.  This implementation
     * interrupts tasks via {@link Thread#interrupt}; any task that
     * fails to respond to interrupts may never terminate.
     *
     * @throws SecurityException {@inheritDoc}
     */
    public List<Runnable> shutdownNow() {
        List<Runnable> tasks;
        final ReentrantLock mainLock = this.mainLock;
        mainLock.lock();
        try {
            checkShutdownAccess();
            //设置线程池状态为STOP
            advanceRunState(STOP);
            //中断线程池中所有线程
            interruptWorkers();
            //导出未处理的task
            tasks = drainQueue();
        } finally {
            mainLock.unlock();
        }
        tryTerminate();
        //返回当前任务队列中 未处理的任务。
        return tasks;
    }
    
```

## 6、 tryTerminate方法



```java
   /**
     * Transitions to TERMINATED state if either (SHUTDOWN and pool
     * and queue empty) or (STOP and pool empty).  If otherwise
     * eligible to terminate but workerCount is nonzero, interrupts an
     * idle worker to ensure that shutdown signals propagate. This
     * method must be called following any action that might make
     * termination possible -- reducing worker count or removing tasks
     * from the queue during shutdown. The method is non-private to
     * allow access from ScheduledThreadPoolExecutor.
     */
    final void tryTerminate() {
        for (;;) {
            int c = ctl.get();
            //条件一：isRunning(c)  成立，直接返回就行，线程池很正常！
            //条件二：runStateAtLeast(c, TIDYING) 说明 已经有其它线程 在执行 TIDYING -> TERMINATED状态了,当前线程直接回去。
            //条件三：(runStateOf(c) == SHUTDOWN && ! workQueue.isEmpty())
            //SHUTDOWN特殊情况，如果是这种情况，直接回去。得等队列中的任务处理完毕后，再转化状态。
            if (isRunning(c) ||
                runStateAtLeast(c, TIDYING) ||
                (runStateLessThan(c, STOP) && ! workQueue.isEmpty()))
                return;

            //什么情况会执行到这里？
            //1.线程池状态 >= STOP
            //2.线程池状态为 SHUTDOWN 且 队列已经空了

            //条件成立：当前线程池中的线程数量 > 0
            if (workerCountOf(c) != 0) { // Eligible to terminate
                //中断一个空闲线程。
                //空闲线程，在哪空闲呢？ queue.take() | queue.poll()
                //1.唤醒后的线程 会在getTask()方法返回null
                //2.执行退出逻辑的时候会再次调用tryTerminate() 唤醒下一个空闲线程
                //3.因为线程池状态是 （线程池状态 >= STOP || 线程池状态为 SHUTDOWN 且 队列已经空了） 最终调用addWorker时，会失败。
                //最终空闲线程都会在这里退出，非空闲线程 当执行完当前task时，也会调用tryTerminate方法，有可能会走到这里。
                interruptIdleWorkers(ONLY_ONE);
                return;
            }


            //执行到这里的线程是谁？
            //workerCountOf(c) == 0 时，会来到这里。
            //最后一个退出的线程。 咱们知道，在 （线程池状态 >= STOP || 线程池状态为 SHUTDOWN 且 队列已经空了）
            //线程唤醒后，都会执行退出逻辑，退出过程中 会 先将 workerCount计数 -1 => ctl -1。
            //调用tryTerminate 方法之前，已经减过了，所以0时，表示这是最后一个退出的线程了。
            final ReentrantLock mainLock = this.mainLock;
            mainLock.lock();
            try {
                //设置线程池状态为TIDYING状态。
                if (ctl.compareAndSet(c, ctlOf(TIDYING, 0))) {
                    try {
                        // 调用钩子方法
                        terminated();
                    } finally {
                        //设置线程池状态为TERMINATED状态。
                        ctl.set(ctlOf(TERMINATED, 0));
                        //唤醒调用 awaitTermination() 方法的线程。
                        termination.signalAll();
                        container.close();
                    }
                    return;
                }
            } finally {
                mainLock.unlock();
            }
            // else retry on failed CAS
        }
    }

```


